<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: exoweb | The Endless Obsession]]></title>
  <link href="http://endlessobsession.heroku.com/blog/categories/exoweb/atom.xml" rel="self"/>
  <link href="http://endlessobsession.heroku.com/"/>
  <updated>2012-09-04T21:29:05-04:00</updated>
  <id>http://endlessobsession.heroku.com/</id>
  <author>
    <name><![CDATA[Bryan Matthews]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ExoWeb's Entity System]]></title>
    <link href="http://endlessobsession.heroku.com/blog/exowebs-entity-system"/>
    <updated>2011-01-13T06:34:46-05:00</updated>
    <id>http://endlessobsession.heroku.com/blog/exowebs-entity-system</id>
    <content type="html"><![CDATA[<p>Matt Hooper recently posted an <a href="http://mhoop.wordpress.com/2011/01/13/exowebs-entity-system/">overview of ExoWeb's entity system</a>.</p>

<p>From the post:</p>

<blockquote><p>We've done our best to make sure the parts and pieces that comprise the ExoWeb entity system work consistently, fit together cleanly and take advantage of JavaScripts language features.</p></blockquote>

<p>Go check it out!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Intro to Client-Server Mapping in ExoWeb]]></title>
    <link href="http://endlessobsession.heroku.com/blog/into-to-client-server-mapping-in-exoweb"/>
    <updated>2011-01-10T10:28:34-05:00</updated>
    <id>http://endlessobsession.heroku.com/blog/into-to-client-server-mapping-in-exoweb</id>
    <content type="html"><![CDATA[<p>As a follow up to my <a href="www.google.com">Brief Introduction to ExoWeb</a>, I would like to go into more detail about the communications between client and server.</p>

<p>The client interacts with the server in two basic ways.</p>

<ol>
<li><p>Pulling information: type and instance data.</p></li>
<li><p>Pushing information: changes to the model and/or instructions to do something.</p></li>
</ol>


<p>The first type, pulling information, is pretty straightforward. Type information doesn’t change (frequently) so it is actually cached on the client if possible. Querying for instance data is similar to querying a database. You request an object of a particular type with a particular id, but you can also include a set of paths that tell the services what additional related data you are interested in. The primary component of a query might look something like this.</p>

<pre><code>{ from: "Person", id: "1", and: ["this.Additional.Properties.To.Load"] }
</code></pre>

<p>The second type, pushing information, gets a little more interesting. If you’re going to sync data between two disconnected systems there are two primary approaches that you might take. First, you could send simple data from point A to point B, manipulate it, then send it back from point B to point A in the same form. As you could imagine this can get pretty expensive and tedious. Of course, you might just send the portions of data that have changed to cut down on overhead. The bigger problem, I think, is that you don’t really know what has happened unless you do full graph comparisons. Another approach is to keep track of <em>changes</em> as they occur and send those back and forth. This is what ExoWeb does.</p>

<pre><code>changes: [ { type: "ValueChange", instance: { id: "1", type: "Person" }, property: "FirstName", oldValue: "Rob", newValue: "Robert" }, ... } ]
</code></pre>

<p>The client can also raise events, for example “save”, a built-in event. In response, the server can send back additional changes to the model.</p>

<pre><code>changes: [ { type: "Save", idChanges: [ { type: "Person", from: "?4", to: "644" } ] }, ... ]
</code></pre>

<p>The payload isn’t limited to data. It can also include conditions, for example, permissions, or invalid data conditions. More on that later.</p>

<p>This has been a very basic introduction to the way client-server communication works in ExoWeb. Look out for more updates in the future.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A Brief Introduction to ExoWeb]]></title>
    <link href="http://endlessobsession.heroku.com/blog/a-brief-introduction-to-exoweb"/>
    <updated>2011-01-10T07:54:17-05:00</updated>
    <id>http://endlessobsession.heroku.com/blog/a-brief-introduction-to-exoweb</id>
    <content type="html"><![CDATA[<p><a href="http://mattheyan.posterous.com/2010/12/07/exo-suite-and-client-scripts-on-github">A while back</a> I talked about the ExoWeb project and scripts that are now hosted on github.  That post was a little vague because not much has been documented about what you can actually do with ExoWeb.  That’s what I hope to do here.</p>

<p>First off, let me restate the purpose of ExoWeb as simply as I can.  ExoWeb exists to bridge the gap between the client and server.  You can think of it as a combination client-server mapper and model-view mapper.</p>

<h2>Client Server Mapping</h2>

<p>When I say that ExoWeb is a client-server mapper what I mean is that it handles mapping from an object model on the server to the client (and vice versa) in much the same way that an ORM maps from a database schema to an object model.  The general idea is that you’re persisting objects and that you would like to be able to easily manipulate those objects in JavaScript code, without any extra work.</p>

<p>For example, say you have a C# class that is persisted to a database using your choice of ORM.</p>

<pre><code>public class Person
{
    public string FirstName { get; set; }
    public string LastName { get; set; }
    public string FullName
    {
        get
        {
            return FirstName + " " + LastName;
        }
    }
}
</code></pre>

<p>You would want to be able to write JavaScript code to modify this object like so (ignoring the details of the syntax [1]).</p>

<pre><code>person.set_FirstName("Bob");
</code></pre>

<p>ExoWeb aims to let you do this with very little effort.</p>

<p>What are some of the things that you might want to do with the model?</p>

<ul>
<li><p>Have the full name automatically reflect the fact that the first name is now “Bob”</p></li>
<li><p>Save these changes by simply calling a method</p></li>
<li><p>“Round trip” to the server to perform complex or sensitive operations</p></li>
<li><p>Display the person’s information in a view</p></li>
</ul>


<p>…which leads us to the next primary area of functionality.</p>

<h2>View Model Mapping</h2>

<p>You have a model on the client, so now you want to display some information to the user and possibly accept input.  What are some of the tools that you might want to have at your disposal?</p>

<ul>
<li><p>Create regions in your form that correspond to lists in the model</p></li>
<li><p>Two-way binding of properties to inputs elements and form regions</p></li>
<li><p>Respond to changes and redraw parts of the form as needed</p></li>
<li><p>Attach behavior to the form such as clicking links, toggling regions, etc</p></li>
<li><p>Take advantage of model metadata like formats, allowed values, validation rules, etc</p></li>
<li><p>Allow for lazy loading of certain information when it is needed on the form</p></li>
</ul>


<p>That’s a glance at the basic features that we want from ExoWeb.  So, what does it actually look like?</p>

<p><em>Disclaimer:  ExoWeb is under heavy development, so this stuff is always changing.  Feedback is welcome.</em></p>

<h2>Setting up a Page</h2>

<p>First off we have to include the ExoWeb script(s).  Take a look at the <a href="http://github.com/mattheyan/exoweb">github repo</a> to see what’s available.  The “dist” folder contains 3 scripts: exoweb-msajax.js, exoweb-msajax-nojquery.js, and jquery.exoweb-msajax.js.  For now we’ll just include exoweb-msajax.js.  ExoWeb currently also requires jQuery (1.3 or 1.4) and the MsAjax client libraries (specifically, MicrosoftAjax.js and MicrosoftAjaxTemplates.js).  These will be included in the repo in the near future.</p>

<p><em>Side note:  ExoWeb currently uses the MsAjax client libraries, primarily for two purposes: observer and integrated template rendering.  In the near future these dependencies should be isolated so that other implementations could be used.  For example, better integration with jQuery is a personal goal of mine.</em></p>

<p>Now that we have the right scripts included we need to set up the page’s context.  This tells ExoWeb what data to load and what to do before and after it is loaded.  We do this by calling the $exoweb function.  It accepts a JavaScript object with any of the following properties.</p>

<ul>
<li><p>model: A JavaScript object that defines the data to load from the server.</p></li>
<li><p>types: An array of types to load.  This is usually not needed since types are automatically loaded based on the “model” parameter.</p></li>
<li><p>init:  A function that is invoked as soon as model or type data has been requested.</p></li>
<li><p>contextReady: A function that is invoked as soon as the model or type data has been loaded, but before the UI is rendered.</p></li>
<li><p>domReady: A function that is invoked after the UI has been rendered.</p></li>
</ul>


<p>You can call $exoweb any number of times, and as an example our query might look something like this (please forgive the contrived example).</p>

<pre><code>$exoweb({
    init: function() {
        ExoWeb.UI.Template.load("/path/to/template");
    },
    types: [
        {
            from: "CustomWidget",
            and: ["this.CustomInformation"]
        }
    ],
    model: {
        widget: {
            from: "Widget",
            id: "1",
            and: ["this.Type.DefaultPrice"]
        }
    },
    contextReady: function() {
        context.model.widget.doSomething();
    },
    domReady: function() {
        $(".widget input[type=button].save").click(function() {
            context.server.save(context.model.widget);
        });
    }
});
</code></pre>

<p>During init we want to load an external template file.  I will talk more about this in the future, but for now I will say that ExoWeb allows you to bind parts of your form to a dynamic template that is selected based on the HTML element and the data that will be rendered.  This allows you to break out reusable templates for common display scenarios, but it also allows your form to be dynamic in the sense that the markup can change automatically based on user input.</p>

<p>The types and model portions are what trigger requests to the server.  This will load up all of the metadata that is needed, as well as the instance data for the instances and paths that you specify.  When the context is ready it will have a model property that contains a property for each thing that you requested (in this case, the widget).</p>

<p>Context ready allows you to perform custom operations after all of your data is loaded.  For example, if you have an add/edit page you can perform setup logic that may be needed only in the add scenario.</p>

<p>DOM ready is a good place to put any DOM manipulation code that is specific to your page and it’s data and templates.  For general UI behavior I would recommend using jQuery to attach behavior as needed based on css selectors (a topic for another day).  Notice here the use of the “server” object, which is found on the context.  The server object allows you to save, round trip, raise events, and inspect the changes that have occurred.</p>

<p>Now, to display this on the form we might write something like this.</p>

<pre><code>&lt;div class="sys-template widget" sys:attach="dataview"
    dataview:data="{~ context.model.widget, source= }"&gt;
    &lt;h3&gt;Editing &lt;span&gt;{binding Name}&lt;/span&gt;&lt;/h3&gt;
    &lt;div class="sys-template" sys:attach="dataview" dataview:data="{@ Type }"&gt;
        &lt;label&gt;Type:&lt;/label&gt;
        &lt;select class="sys-template" sys:value="{binding systemValue}"
            sys:attach="dataview" dataview:data="{binding options}"&gt;
            &lt;option value="{binding systemValue}"&gt;{binding displayValue}
                &lt;/option&gt;
        &lt;/select&gt;
    &lt;/div&gt;
    &lt;div class="sys-template" sys:attach="dataview" dataview:data="{@ Price }"&gt;
        &lt;label&gt;Price:&lt;/label&gt;
        &lt;input type="text" sys:value="{binding displayValue}" /&gt;
    &lt;/div&gt;
    &lt;input type="button" class="save" value="Save" /&gt;
&lt;/div&gt;
</code></pre>

<p>The form is not rendered until the “widget” object has been loaded.  Also, notice the “@” extension that is used to incorporate metadata in the form.  For a pick list it will give you the list of options for a particular property.  Also, for other properties it allows you to automatically convert from and to a “system” or “display” format.  In a nutshell, the “display” format is a human-readable form of the underlying data that also includes format conditions for things like email, phone number, etc, while the “system” format is not intended to be shown to a user but instead can be used to uniquely identify an object.</p>

<p>This has been a very brief introduction to ExoWeb.  There is much more to talk about and you can expect follow up posts in the near future.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Exo-suite (and client scripts on Github)]]></title>
    <link href="http://endlessobsession.heroku.com/blog/exo-suite-and-client-scripts-on-github"/>
    <updated>2010-12-07T19:07:12-05:00</updated>
    <id>http://endlessobsession.heroku.com/blog/exo-suite-and-client-scripts-on-github</id>
    <content type="html"><![CDATA[<p>Off and on at <a href="http://vc3.com/">work</a> over the last year or so I have been working on an open-source project called <a href="http://exoweb.codeplex.com/">ExoWeb</a>, as well as supporting projects called <a href="http://exograph.codeplex.com/">ExoGraph</a> and ExoRule.  ExoWeb and ExoGraph are hosted on <a href="http://codeplex.com/">Codeplex</a>, though they are somewhat stale at this point.</p>

<p>Before I go any farther I'll give you (and future self) my take on the purpose of these projects.</p>

<h3>ExoGraph</h3>

<p>...is essentially an enabler.</p>

<p>From the codeplex site:</p>

<blockquote><p>ExoGraph is a graph library that leverages type information to optimize graph operations and notifications. The library exposes type-level events for object initialization, property retrieval, property path changes, and custom domain events within a graph context.</p></blockquote>

<p>This doesn't sound very useful in and of itself, right?  Well, it's not supposed to be.  It's an enabler, remember?  That's where ExoWeb and ExoRule come in...</p>

<h3>ExoRule</h3>

<p>...is a rules framework that leverages ExoGraph.  That is all for now.</p>

<h3>ExoWeb</h3>

<p>...is a JavaScript framework, basically.  It also relies on a supporting server-side web request handler as well as a working ExoGraph implementation.</p>

<p>From the codeplex site, ExoWeb...</p>

<blockquote><p>...aims to provide a rich JavaScript object model, intuitive UI code based on the fundamental languages of the web (HTML, CSS, and JavaScript), model- and UI-driven validation, and seamless synchronization of changes between client and server.</p></blockquote>

<p>That may not be crystal-clear, but fortunately you can browse the source, which is what I really want to write about anyway.</p>

<p>The JavaScript source is now <a href="http://github.com/mattheyan/exoweb">hosted on Github</a>.  If you take a look at the <a href="http://exoweb.codeplex.com/SourceControl/list/changesets">source on Codeplex</a> you'll notice that there are 8 script files: exoweb.js, exoweb.model.js, exoweb.mapper.js, exoweb.view.js, exoweb.ui.js, exoweb.mock.js, exoweb.jquery.js, and start.debug.js.  The source on Github, however, has many more script files as well as specs (using jasmine) and a build process (using rake) that produces the scripts listed above.  It is loosely modeled after the <a href="http://github.com/jquery/jquery">jquery source</a>.</p>

<p>I have a few goals in hosting the project on Github.</p>

<ol>
<li><p>Isolate classes and related functions in order to make it easier to manage, illuminate code structure, improve architecture and design, and limit dependencies.</p></li>
<li><p>Allow for (hopefully) isolated testing of individual classes and functions.</p></li>
<li><p>Isolate the bulk of the code which is not dependent on any particular JavaScript library or server-side technology.</p></li>
<li><p>Take advantage of github's popularity in open source software collaboration, and...well, I just like Github.</p></li>
</ol>


<p>At the time of this writing the project produces the destination scripts that more or less match the scripts in the original project (not the ones on codeplex, they're old).  Also, a few of the source files have corresponding specs that pass, using <a href="http://nodejs.org/">nodejs</a> to run them.</p>

<p>Finally, in writing the build script, I got the chance to learn a little <a href="http://rake.rubyforge.org/">rake</a> (ruby make), which I highly recommend.</p>

<p>One of my other goals is to create working ExoGraph/ExoWeb implementations for django and rails.  The beginnings of the django implementation is currently <a href="http://github.com/mattheyan/django-exoweb">hosted on Github</a> as well.</p>
]]></content>
  </entry>
  
</feed>
